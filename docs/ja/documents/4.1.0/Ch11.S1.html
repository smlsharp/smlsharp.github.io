---
layout: default
permalink: /ja/documents/4.1.0/Ch11.S1.html
translated: true
lang: ja
head: |
 <!--Generated on Sat Nov 16 16:41:37 2024 by LaTeXML (version 0.8.5) http://dlmf.nist.gov/LaTeXML/.-->
 <!--Document created on 令和6年11月.-->
 <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
 <link rel="stylesheet" href="LaTeXML.css" type="text/css">
 <link rel="stylesheet" href="ltx-book.css" type="text/css">
 <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=MML_CHTML" type="text/javascript"></script>
 <link rel="up" href="Ch11.html" title="Chapter 11 SML#の拡張機能：マルチスレッドプログラミング ‣ Part II チュートリアル ‣ プログラミング言語SML#解説 4.1.0版">
 <link rel="up up" href="Pt2.html" title="Part II チュートリアル ‣ プログラミング言語SML#解説 4.1.0版">
 <link rel="up up up" href="./" title="プログラミング言語SML#解説 4.1.0版">
 <link rel="start" href="./" title="プログラミング言語SML#解説 4.1.0版">
 <link rel="prev" href="Ch11.html" title="Chapter 11 SML#の拡張機能：マルチスレッドプログラミング ‣ Part II チュートリアル ‣ プログラミング言語SML#解説 4.1.0版">
 <link rel="next" href="Ch11.S2.html" title="11.2 MassiveThreadsを用いた細粒度スレッドプログラミング ‣ Chapter 11 SML#の拡張機能：マルチスレッドプログラミング ‣ Part II チュートリアル ‣ プログラミング言語SML#解説 4.1.0版">
 <link rel="section" href="Ch11.S2.html" title="11.2 MassiveThreadsを用いた細粒度スレッドプログラミング ‣ Chapter 11 SML#の拡張機能：マルチスレッドプログラミング ‣ Part II チュートリアル ‣ プログラミング言語SML#解説 4.1.0版">
 <link rel="chapter" href="Ch5.html" title="Chapter 5 SML#のインストール ‣ Part II チュートリアル ‣ プログラミング言語SML#解説 4.1.0版">
 <link rel="chapter" href="Ch6.html" title="Chapter 6 SML#プログラミング環境の準備 ‣ Part II チュートリアル ‣ プログラミング言語SML#解説 4.1.0版">
 <link rel="chapter" href="Ch7.html" title="Chapter 7 MLプログラミング入門 ‣ Part II チュートリアル ‣ プログラミング言語SML#解説 4.1.0版">
 <link rel="chapter" href="Ch8.html" title="Chapter 8 SML#の拡張機能：レコード多相性 ‣ Part II チュートリアル ‣ プログラミング言語SML#解説 4.1.0版">
 <link rel="chapter" href="Ch9.html" title="Chapter 9 SML#の拡張機能：その他の型の拡張 ‣ Part II チュートリアル ‣ プログラミング言語SML#解説 4.1.0版">
 <link rel="chapter" href="Ch10.html" title="Chapter 10 SML#の拡張機能：Cとの直接連携 ‣ Part II チュートリアル ‣ プログラミング言語SML#解説 4.1.0版">
 <link rel="chapter" href="Ch11.html" title="Chapter 11 SML#の拡張機能：マルチスレッドプログラミング ‣ Part II チュートリアル ‣ プログラミング言語SML#解説 4.1.0版">
 <link rel="chapter" href="Ch12.html" title="Chapter 12 SML#の拡張機能：SQLの統合 ‣ Part II チュートリアル ‣ プログラミング言語SML#解説 4.1.0版">
 <link rel="chapter" href="Ch13.html" title="Chapter 13 SML#の拡張機能：動的型付け機構とJSONの型付き操作 ‣ Part II チュートリアル ‣ プログラミング言語SML#解説 4.1.0版">
 <link rel="chapter" href="Ch14.html" title="Chapter 14 SML#の拡張機能：SML#分割コンパイルシステム ‣ Part II チュートリアル ‣ プログラミング言語SML#解説 4.1.0版">
 <link rel="part" href="Pt1.html" title="Part I 概要 ‣ プログラミング言語SML#解説 4.1.0版">
 <link rel="part" href="Pt2.html" title="Part II チュートリアル ‣ プログラミング言語SML#解説 4.1.0版">
 <link rel="part" href="Pt3.html" title="Part III 参照マニュアル ‣ プログラミング言語SML#解説 4.1.0版">
 <link rel="part" href="Pt4.html" title="Part IV プログラミングツール ‣ プログラミング言語SML#解説 4.1.0版">
 <link rel="part" href="Pt5.html" title="Part V SML#の内部構造 ‣ プログラミング言語SML#解説 4.1.0版">
 <link rel="part" href="Pt6.html" title="Part VI 参考文献，その他 ‣ プログラミング言語SML#解説 4.1.0版">
title: "11.1 Pthreadsプログラミング‣ Chapter 11 SML#の拡張機能：マルチスレッドプログラミング ‣ Part II チュートリアル ‣ プログラミング言語SML#解説 4.1.0版"
---
{% raw %}
<div class="ltx_page_main">
<header class="ltx_page_header"><div class="ltx_document_title">プログラミング言語SML#解説 4.1.0版</div>
<div>
<a href="Ch11.html" title="Chapter 11 SML#の拡張機能：マルチスレッドプログラミング ‣ Part II チュートリアル ‣ プログラミング言語SML#解説 4.1.0版" class="ltx_ref" rel="up"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">11 </span>
SML#の拡張機能：マルチスレッドプログラミング</span></a><a href="Ch11.html" title="Chapter 11 SML#の拡張機能：マルチスレッドプログラミング ‣ Part II チュートリアル ‣ プログラミング言語SML#解説 4.1.0版" class="ltx_ref" rel="prev"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">11 </span>
SML#の拡張機能：マルチスレッドプログラミング</span></a><a href="Ch11.S2.html" title="11.2 MassiveThreadsを用いた細粒度スレッドプログラミング ‣ Chapter 11 SML#の拡張機能：マルチスレッドプログラミング ‣ Part II チュートリアル ‣ プログラミング言語SML#解説 4.1.0版" class="ltx_ref" rel="next"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">11.2 </span>MassiveThreadsを用いた細粒度スレッドプログラミング</span></a>
</div></header>
<div class="ltx_page_content">
<section class="ltx_section ltx_authors_1line">
<h1 class="ltx_title ltx_title_section">
<span class="ltx_tag ltx_tag_section">11.1 </span>Pthreadsプログラミング</h1>

<div id="p1" class="ltx_para">
<p class="ltx_p">OSが提供するPthreadsライブラリを
ほぼそのままバインドした<span class="ltx_text ltx_font_typewriter">Pthread</span>ストラクチャが
標準で提供されています．
スレッドを生成する<span class="ltx_text ltx_font_typewriter">pthread_create</span>関数および
結合する<span class="ltx_text ltx_font_typewriter">pthread_join</span>関数は以下の名前と型で提供されます．</p>
<blockquote class="ltx_quote">
<p class="ltx_p"><span class="ltx_text ltx_font_typewriter">Pthread.Thread.create : (unit -&gt; int) -&gt; Pthread.thread
<br class="ltx_break">
Pthread.Thread.join : Pthread.thread -&gt; int</span></p>
</blockquote>
<p class="ltx_p">マルチスレッドプログラミングの例として，
これらの関数を組み合わせ，時間のかかる計算を別スレッドで
行うプログラムを書いてみましょう．
以下は，<span class="ltx_text ltx_font_typewriter">fib 42</span>をバックグラウンドで計算するプログラムを，
対話モードで書いた例です．</p>
<blockquote class="ltx_quote">
<p class="ltx_p"><span class="ltx_text ltx_font_typewriter"># fun fib 0 = 0 | fib 1 = 1 | fib n = fib (n - 1) + fib (n - 2);
<br class="ltx_break">
val fib = fn : int -&gt; int
<br class="ltx_break">
# val t = Pthread.Thread.create (fn _ =&gt; fib 42); 
<br class="ltx_break">
val t = ptr : Pthread.thread
<br class="ltx_break">
# Pthread.Thread.join t;
<br class="ltx_break">
val it = 267914296 : int</span></p>
</blockquote>
</div>
<div id="p2" class="ltx_para">
<p class="ltx_p">SML#は独自のスレッドプリミティブを用意していません．
また，SML#は，Pthreadライブラリに対して，何か特別な
ことをしているわけでもありません．
C関数のインポート機能とコールバック機能を組み合わせ，
Pthreadライブラリをインポートすることで，
SML#でネイティブなマルチスレッドプログラミングができます．
SML#のコールバック機能は，C関数を呼び出したスレッドとは
異なるスレッドからコールバックされたとしても，期待通りに動くように
設計されています．
そのため，SML#では，スレッドを生成する可能性のあるどの
C関数も，ただそのままインポートし呼び出すだけで，スレッド生成機能を含めた
全ての機能を，SML#から活用することができます．
従って，Pthreadライブラリに限らず，例えば別スレッドで
非同期的にコールバック関数を呼び出すサウンドプログラミングライブラリ
なども，SML#にインポートし，コールバックルーチンをSML#で
書くことができます．
もちろん，ユーザーが作成した独自のスレッドライブラリをSML#から
使用することもできます．
上述した<span class="ltx_text ltx_font_typewriter">Pthread</span>ストラクチャも，
Pthreadライブラリが定義する関数群を
SML#にインポートして定義されています．</p>
</div>
<div id="p3" class="ltx_para">
<p class="ltx_p">Pthreadライブラリをインポートして，SML#から使ってみましょう．
まず，スレッドのハンドルの型<span class="ltx_text ltx_font_typewriter">pthread_t</span>に対応するSML#の
型を決める必要があります．
このマニュアルの執筆時点では，<span class="ltx_text ltx_font_typewriter">pthread_t</span>はLinuxでは
<span class="ltx_text ltx_font_typewriter">unsigned long int</span>，macOSではポインタと定義されています．
どちらのプラットフォームでも，<span class="ltx_text ltx_font_typewriter">pthread_t</span>はポインタと同じ大きさ
を持つ不透明な基本型と見なすことができますので，
SML#では<span class="ltx_text ltx_font_typewriter">pthread_t</span>を以下のように定義することにします．</p>
<blockquote class="ltx_quote">
<p class="ltx_p"><span class="ltx_text ltx_font_typewriter">type pthread_t = unit ptr</span></p>
</blockquote>
<p class="ltx_p">スレッドを生成する<span class="ltx_text ltx_font_typewriter">pthread_create</span>関数の型は，以下のように
インポートすることができます．</p>
<blockquote class="ltx_quote">
<p class="ltx_p"><span class="ltx_text ltx_font_typewriter">val pthread_create =
<br class="ltx_break">
    _import "pthread_create"
<br class="ltx_break">
    : (pthread_t ref, unit ptr, unit ptr -&gt; unit ptr, unit ptr) -&gt; int</span></p>
</blockquote>
<p class="ltx_p">この関数を呼び出しスレッドを生成する関数<span class="ltx_text ltx_font_typewriter">spawn</span>を書きましょう．
第2引数はスレッドの属性，
第4引数はコールバック関数に渡す引数ですが，
ここでは使用しないので，これらには<span class="ltx_text ltx_font_typewriter">NULL</span>を渡すことにします．
<span class="ltx_text ltx_font_typewriter">NULL</span>ポインタは<span class="ltx_text ltx_font_typewriter">Pointer.NULL ()</span>で得られます．
従って，<span class="ltx_text ltx_font_typewriter">spawn</span>関数は以下のように定義できます（エラー処理
は省略します）．</p>
<blockquote class="ltx_quote">
<p class="ltx_p"><span class="ltx_text ltx_font_typewriter">fun spawn f =
<br class="ltx_break">
    let
<br class="ltx_break">
      val r = ref (Pointer.NULL ())
<br class="ltx_break">
    in
<br class="ltx_break">
      pthread_create (r,
<br class="ltx_break">
                      Pointer.NULL (),
<br class="ltx_break">
                      fn _ =&gt; (f () : unit; Pointer.NULL ()),
<br class="ltx_break">
                      Pointer.NULL ());
<br class="ltx_break">
      !r
<br class="ltx_break">
    end</span></p>
</blockquote>
<p class="ltx_p">同様に，スレッドの終了を待つ関数<span class="ltx_text ltx_font_typewriter">pthread_join</span>も，簡単に
インポートできます．</p>
<blockquote class="ltx_quote">
<p class="ltx_p"><span class="ltx_text ltx_font_typewriter">val pthread_join =
<br class="ltx_break">
    _import "pthread_join"
<br class="ltx_break">
    : (pthread_t, unit ptr ref) -&gt; int
<br class="ltx_break">
fun join t =
<br class="ltx_break">
    (pthread_join (t, ref (Pointer.NULL ())); ())</span></p>
</blockquote>
</div>
<div id="p4" class="ltx_para">
<p class="ltx_p">このようにして定義した<span class="ltx_text ltx_font_typewriter">spawn</span>と<span class="ltx_text ltx_font_typewriter">join</span>を使って
この節冒頭の例と同じプログラムを対話モードで書くと以下のようになります．</p>
<blockquote class="ltx_quote">
<p class="ltx_p"><span class="ltx_text ltx_font_typewriter"># fun fib 0 = 0 | fib 1 = 1 | fib n = fib (n - 1) + fib (n - 2);
<br class="ltx_break">
val fib = fn : int -&gt; int
<br class="ltx_break">
# val r = ref 0;
<br class="ltx_break">
val r = ref 0 : int ref
<br class="ltx_break">
# fun g () = r := fib 42;
<br class="ltx_break">
val g = unit -&gt; unit
<br class="ltx_break">
# val t = spawn g;
<br class="ltx_break">
val t = ptr : unit ptr
<br class="ltx_break">
# join t;
<br class="ltx_break">
val it = () : unit
<br class="ltx_break">
# !r;
<br class="ltx_break">
val it = 267914296 : int</span></p>
</blockquote>
<p class="ltx_p">なお，</p>
<blockquote class="ltx_quote">
<p class="ltx_p"><span class="ltx_text ltx_font_typewriter"># val t = spawn g;</span></p>
</blockquote>
<p class="ltx_p">の行を</p>
<blockquote class="ltx_quote">
<p class="ltx_p"><span class="ltx_text ltx_font_typewriter"># val t = spawn (fn () =&gt; r := fib 42);</span></p>
</blockquote>
<p class="ltx_p">と書くことは危険です．
なぜなら，ガベージコレクタが関数式の生成するクロージャを
別スレッドで関数が呼び出される前に回収してしまう可能性があるからです．
ガベージコレクションの影響については<a href="Ch29.S2.html" title="29.2 ガーベジコレクションの影響 ‣ Chapter 29 SML#実行時データ管理 ‣ Part III 参照マニュアル ‣ プログラミング言語SML#解説 4.1.0版" class="ltx_ref"><span class="ltx_text ltx_ref_tag">29.2</span></a>節を
参照してください．</p>
</div>
</section>
</div>
<footer class="ltx_page_footer">
<div>
<a href="Ch11.html" title="Chapter 11 SML#の拡張機能：マルチスレッドプログラミング ‣ Part II チュートリアル ‣ プログラミング言語SML#解説 4.1.0版" class="ltx_ref" rel="prev"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">11 </span>
SML#の拡張機能：マルチスレッドプログラミング</span></a><a href="Ch11.S2.html" title="11.2 MassiveThreadsを用いた細粒度スレッドプログラミング ‣ Chapter 11 SML#の拡張機能：マルチスレッドプログラミング ‣ Part II チュートリアル ‣ プログラミング言語SML#解説 4.1.0版" class="ltx_ref" rel="next"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">11.2 </span>MassiveThreadsを用いた細粒度スレッドプログラミング</span></a>
</div>
<div class="ltx_page_logo">Generated  on Sat Nov 16 16:41:37 2024 by <a href="http://dlmf.nist.gov/LaTeXML/">LaTeXML <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAAOCAYAAAD5YeaVAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9wKExQZLWTEaOUAAAAddEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIFRoZSBHSU1Q72QlbgAAAdpJREFUKM9tkL+L2nAARz9fPZNCKFapUn8kyI0e4iRHSR1Kb8ng0lJw6FYHFwv2LwhOpcWxTjeUunYqOmqd6hEoRDhtDWdA8ApRYsSUCDHNt5ul13vz4w0vWCgUnnEc975arX6ORqN3VqtVZbfbTQC4uEHANM3jSqXymFI6yWazP2KxWAXAL9zCUa1Wy2tXVxheKA9YNoR8Pt+aTqe4FVVVvz05O6MBhqUIBGk8Hn8HAOVy+T+XLJfLS4ZhTiRJgqIoVBRFIoric47jPnmeB1mW/9rr9ZpSSn3Lsmir1fJZlqWlUonKsvwWwD8ymc/nXwVBeLjf7xEKhdBut9Hr9WgmkyGEkJwsy5eHG5vN5g0AKIoCAEgkEkin0wQAfN9/cXPdheu6P33fBwB4ngcAcByHJpPJl+fn54mD3Gg0NrquXxeLRQAAwzAYj8cwTZPwPH9/sVg8PXweDAauqqr2cDjEer1GJBLBZDJBs9mE4zjwfZ85lAGg2+06hmGgXq+j3+/DsixYlgVN03a9Xu8jgCNCyIegIAgx13Vfd7vdu+FweG8YRkjXdWy329+dTgeSJD3ieZ7RNO0VAXAPwDEAO5VKndi2fWrb9jWl9Esul6PZbDY9Go1OZ7PZ9z/lyuD3OozU2wAAAABJRU5ErkJggg==" alt="[LOGO]"></a>
</div></footer>
</div>
{% endraw %}
