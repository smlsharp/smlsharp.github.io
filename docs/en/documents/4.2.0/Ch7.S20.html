<!DOCTYPE html><html>
<head>
<title>7.20 Polymorphic functions‣ Chapter 7 Introduction to ML programming ‣ Part II Tutorials ‣ SML# Document Version 4.2.0</title>
<!--Generated on Tue Mar 25 14:56:23 2025 by LaTeXML (version 0.8.5) http://dlmf.nist.gov/LaTeXML/.-->
<!--Document created on Mar, 2025.-->

<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" href="LaTeXML.css" type="text/css">
<link rel="stylesheet" href="ltx-book.css" type="text/css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=MML_CHTML" type="text/javascript"></script>
<link rel="up" href="Ch7.html" title="Chapter 7 Introduction to ML programming ‣ Part II Tutorials ‣ SML# Document Version 4.2.0">
<link rel="up up" href="Pt2.html" title="Part II Tutorials ‣ SML# Document Version 4.2.0">
<link rel="up up up" href="./" title="SML# Document Version 4.2.0">
<link rel="start" href="./" title="SML# Document Version 4.2.0">
<link rel="prev" href="Ch7.S19.html" title="7.19 Principle in composing expressions ‣ Chapter 7 Introduction to ML programming ‣ Part II Tutorials ‣ SML# Document Version 4.2.0">
<link rel="next" href="Ch8.html" title="Chapter 8 SML# feature: record polymorphism ‣ Part II Tutorials ‣ SML# Document Version 4.2.0">
<link rel="section" href="Ch7.S1.html" title="7.1 About the ML language family ‣ Chapter 7 Introduction to ML programming ‣ Part II Tutorials ‣ SML# Document Version 4.2.0">
<link rel="section" href="Ch7.S2.html" title="7.2 Declarative programming ‣ Chapter 7 Introduction to ML programming ‣ Part II Tutorials ‣ SML# Document Version 4.2.0">
<link rel="section" href="Ch7.S3.html" title="7.3 Representing computation by composing expressions ‣ Chapter 7 Introduction to ML programming ‣ Part II Tutorials ‣ SML# Document Version 4.2.0">
<link rel="section" href="Ch7.S4.html" title="7.4 Constants literals and built-in primitives ‣ Chapter 7 Introduction to ML programming ‣ Part II Tutorials ‣ SML# Document Version 4.2.0">
<link rel="section" href="Ch7.S5.html" title="7.5 Type bool and conditional expressions ‣ Chapter 7 Introduction to ML programming ‣ Part II Tutorials ‣ SML# Document Version 4.2.0">
<link rel="section" href="Ch7.S6.html" title="7.6 Compound expressions and function definitions ‣ Chapter 7 Introduction to ML programming ‣ Part II Tutorials ‣ SML# Document Version 4.2.0">
<link rel="section" href="Ch7.S7.html" title="7.7 Recursive functions ‣ Chapter 7 Introduction to ML programming ‣ Part II Tutorials ‣ SML# Document Version 4.2.0">
<link rel="section" href="Ch7.S8.html" title="7.8 Functions with multiple arguments ‣ Chapter 7 Introduction to ML programming ‣ Part II Tutorials ‣ SML# Document Version 4.2.0">
<link rel="section" href="Ch7.S9.html" title="7.9 Function application syntax ‣ Chapter 7 Introduction to ML programming ‣ Part II Tutorials ‣ SML# Document Version 4.2.0">
<link rel="section" href="Ch7.S10.html" title="7.10 Higher-order functions ‣ Chapter 7 Introduction to ML programming ‣ Part II Tutorials ‣ SML# Document Version 4.2.0">
<link rel="section" href="Ch7.S11.html" title="7.11 Using higher-order functions ‣ Chapter 7 Introduction to ML programming ‣ Part II Tutorials ‣ SML# Document Version 4.2.0">
<link rel="section" href="Ch7.S12.html" title="7.12 Imperative features of ML ‣ Chapter 7 Introduction to ML programming ‣ Part II Tutorials ‣ SML# Document Version 4.2.0">
<link rel="section" href="Ch7.S13.html" title="7.13 Mutable memory reference types ‣ Chapter 7 Introduction to ML programming ‣ Part II Tutorials ‣ SML# Document Version 4.2.0">
<link rel="section" href="Ch7.S14.html" title="7.14 Left-to-right applicative order evaluation ‣ Chapter 7 Introduction to ML programming ‣ Part II Tutorials ‣ SML# Document Version 4.2.0">
<link rel="section" href="Ch7.S15.html" title="7.15 Procedural control ‣ Chapter 7 Introduction to ML programming ‣ Part II Tutorials ‣ SML# Document Version 4.2.0">
<link rel="section" href="Ch7.S16.html" title="7.16 Loop and tail recursion ‣ Chapter 7 Introduction to ML programming ‣ Part II Tutorials ‣ SML# Document Version 4.2.0">
<link rel="section" href="Ch7.S17.html" title="7.17 let expressions ‣ Chapter 7 Introduction to ML programming ‣ Part II Tutorials ‣ SML# Document Version 4.2.0">
<link rel="section" href="Ch7.S18.html" title="7.18 List data type ‣ Chapter 7 Introduction to ML programming ‣ Part II Tutorials ‣ SML# Document Version 4.2.0">
<link rel="section" href="Ch7.S19.html" title="7.19 Principle in composing expressions ‣ Chapter 7 Introduction to ML programming ‣ Part II Tutorials ‣ SML# Document Version 4.2.0">
<link rel="chapter" href="Ch5.html" title="Chapter 5 Installing SML# ‣ Part II Tutorials ‣ SML# Document Version 4.2.0">
<link rel="chapter" href="Ch6.html" title="Chapter 6 Setting up SML# programming environment ‣ Part II Tutorials ‣ SML# Document Version 4.2.0">
<link rel="chapter" href="Ch7.html" title="Chapter 7 Introduction to ML programming ‣ Part II Tutorials ‣ SML# Document Version 4.2.0">
<link rel="chapter" href="Ch8.html" title="Chapter 8 SML# feature: record polymorphism ‣ Part II Tutorials ‣ SML# Document Version 4.2.0">
<link rel="chapter" href="Ch9.html" title="Chapter 9 SML# feature: other type system extensions ‣ Part II Tutorials ‣ SML# Document Version 4.2.0">
<link rel="chapter" href="Ch10.html" title="Chapter 10 SML# feature: direct interface to C ‣ Part II Tutorials ‣ SML# Document Version 4.2.0">
<link rel="chapter" href="Ch11.html" title="Chapter 11 SML# feature: Multithread programming ‣ Part II Tutorials ‣ SML# Document Version 4.2.0">
<link rel="chapter" href="Ch12.html" title="Chapter 12 SML# feature: seamless SQL integration ‣ Part II Tutorials ‣ SML# Document Version 4.2.0">
<link rel="chapter" href="Ch13.html" title="Chapter 13 SML# feature: dynamic types and typed manipulation of JSON ‣ Part II Tutorials ‣ SML# Document Version 4.2.0">
<link rel="chapter" href="Ch14.html" title="Chapter 14 SML# feature: separate compilation ‣ Part II Tutorials ‣ SML# Document Version 4.2.0">
<link rel="part" href="Pt1.html" title="Part I Overview ‣ SML# Document Version 4.2.0">
<link rel="part" href="Pt2.html" title="Part II Tutorials ‣ SML# Document Version 4.2.0">
<link rel="part" href="Pt3.html" title="Part III Reference manual ‣ SML# Document Version 4.2.0">
<link rel="part" href="Pt4.html" title="Part IV Programming Tools ‣ SML# Document Version 4.2.0">
<link rel="part" href="Pt5.html" title="Part V SML# Internals and Data Structures ‣ SML# Document Version 4.2.0">
<link rel="part" href="Pt6.html" title="Part VI Bibliography and other documents ‣ SML# Document Version 4.2.0">
</head>
<body>
<div class="ltx_page_main">
<header class="ltx_page_header"><div class="ltx_document_title">SML# Document Version 4.2.0</div>
<div>
<a href="Ch7.html" title="Chapter 7 Introduction to ML programming ‣ Part II Tutorials ‣ SML# Document Version 4.2.0" class="ltx_ref" rel="up"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">7 </span>Introduction to ML programming</span></a><a href="Ch7.S19.html" title="7.19 Principle in composing expressions ‣ Chapter 7 Introduction to ML programming ‣ Part II Tutorials ‣ SML# Document Version 4.2.0" class="ltx_ref" rel="prev"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">7.19 </span>Principle in composing expressions</span></a><a href="Ch8.html" title="Chapter 8 SML# feature: record polymorphism ‣ Part II Tutorials ‣ SML# Document Version 4.2.0" class="ltx_ref" rel="next"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">8 </span>SML# feature: record polymorphism</span></a>
</div></header>
<div class="ltx_page_content">
<section class="ltx_section ltx_authors_1line">
<h1 class="ltx_title ltx_title_section">
<span class="ltx_tag ltx_tag_section">7.20 </span>Polymorphic functions</h1>

<div id="p1" class="ltx_para">
<p class="ltx_p">In order to exploit the principle that “expressions are freely
composed as far as they are type consistent”, primitive functions used
to compose expressions should accept expressions of various types.
The primitive <span class="ltx_text ltx_font_typewriter">::</span> to construct a list has the following type.</p>
<blockquote class="ltx_quote">
<p class="ltx_p"><span class="ltx_text ltx_font_typewriter"># op ::;
<br class="ltx_break">
val it = fn : [’a. ’a * ’a list -&gt; ’a list]</span></p>
</blockquote>
<p class="ltx_p"><span class="ltx_text ltx_font_typewriter">op</span> prefix convert infix binary operator into a function
that takes a pair.
This typing indicates that <span class="ltx_text ltx_font_typewriter">::</span> is a function that takes a
value of type <span class="ltx_text ltx_font_typewriter">’a</span> and a value of type <span class="ltx_text ltx_font_typewriter">’a list</span>, which is a
list type whose element type is <span class="ltx_text ltx_font_typewriter">’a</span>, and returns a list of the same
type.
In this typing, <span class="ltx_text ltx_font_typewriter">’a</span> represents an arbitrary type.
The notation <span class="ltx_text ltx_font_typewriter">[’a.<math id="p1.m1" class="ltx_Math" alttext="\cdots" display="inline"><mi mathvariant="normal">⋯</mi></math>]</span> indicates that <span class="ltx_text ltx_font_typewriter">’a</span> in
<math id="p1.m2" class="ltx_Math" alttext="\cdots" display="inline"><mi mathvariant="normal">⋯</mi></math> can be replaced with any type, and corresponds to universally
quantified formula <math id="p1.m3" class="ltx_Math" alttext="\forall a.\cdots" display="inline"><mrow><mo>∀</mo><mi>a</mi><mo>.</mo><mi mathvariant="normal">⋯</mi></mrow></math> in logic.
These types that quantifies over type variables are called <span class="ltx_text ltx_font_italic">polymorphic types</span>, and functions having a polymorphic type are called
<span class="ltx_text ltx_font_bold">polymorphic functions</span>.</p>
</div>
<div id="p2" class="ltx_para">
<p class="ltx_p">Functions defined by composing polymorphic functions are often
polymorphic functions.</p>
<blockquote class="ltx_quote">
<p class="ltx_p"><span class="ltx_text ltx_font_typewriter"># fun cons e L = e :: L;

<br class="ltx_break">
val cons = fn : [’a. ’a -&gt; ’a list -&gt; ’a list]</span></p>
</blockquote>
<p class="ltx_p">In this way, ML compiler infers <span class="ltx_text ltx_font_bold">a most general polymorphic
type</span> for an expression.
To understand this mechanism, consider the following function.</p>
<blockquote class="ltx_quote">
<p class="ltx_p"><span class="ltx_text ltx_font_typewriter">fun twice f x = f (f x);
</span></p>
</blockquote>
<p class="ltx_p"><span class="ltx_text ltx_font_typewriter">twice</span> takes a function and an argument and apply the
function to the argument twice.
Since <span class="ltx_text ltx_font_typewriter">f</span> is applied to <span class="ltx_text ltx_font_typewriter">x</span>, the type of <span class="ltx_text ltx_font_typewriter">x</span> must be
the same as the argument type of <span class="ltx_text ltx_font_typewriter">f</span>.
Moreover, since <span class="ltx_text ltx_font_typewriter">f</span> is applied again to the result of <span class="ltx_text ltx_font_typewriter">f</span>, the result type of <span class="ltx_text ltx_font_typewriter">f</span> must be the same as its argument type.
The most general type satisfying these constraint is the following.</p>
<blockquote class="ltx_quote">
<p class="ltx_p"><span class="ltx_text ltx_font_typewriter">[’a. (’a -&gt; ’a) -&gt; ’a -&gt; ’a]</span></p>
</blockquote>
<p class="ltx_p">ML indeed infers the following typing for <span class="ltx_text ltx_font_typewriter">twice</span>.</p>
<blockquote class="ltx_quote">
<p class="ltx_p"><span class="ltx_text ltx_font_typewriter"># fun twice f x = f (f x);

<br class="ltx_break">
val twice = fn : [’a. (’a -&gt; ’a) -&gt; ’a -&gt; ’a]</span></p>
</blockquote>
</div>
<div id="p3" class="ltx_para">
<p class="ltx_p">ML’s principle in program construction – “expressions are
composed as far as they are type consistent” – is made possible by
this polymorphic type inference mechanism.
<span class="ltx_text ltx_font_typewriter">twice</span> can be combined with any function and a value as far
as the function return the same type as its argument and that the value
has the argument type of the function.
This freedom and constraint is automatically guaranteed by the
inferred typing of <span class="ltx_text ltx_font_typewriter">twice</span>.
</p>
</div>
</section>
</div>
<footer class="ltx_page_footer">
<div>
<a href="Ch7.S19.html" title="7.19 Principle in composing expressions ‣ Chapter 7 Introduction to ML programming ‣ Part II Tutorials ‣ SML# Document Version 4.2.0" class="ltx_ref" rel="prev"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">7.19 </span>Principle in composing expressions</span></a><a href="Ch8.html" title="Chapter 8 SML# feature: record polymorphism ‣ Part II Tutorials ‣ SML# Document Version 4.2.0" class="ltx_ref" rel="next"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">8 </span>SML# feature: record polymorphism</span></a>
</div>
<div class="ltx_page_logo">Generated  on Tue Mar 25 14:56:23 2025 by <a href="http://dlmf.nist.gov/LaTeXML/">LaTeXML <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAAOCAYAAAD5YeaVAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9wKExQZLWTEaOUAAAAddEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIFRoZSBHSU1Q72QlbgAAAdpJREFUKM9tkL+L2nAARz9fPZNCKFapUn8kyI0e4iRHSR1Kb8ng0lJw6FYHFwv2LwhOpcWxTjeUunYqOmqd6hEoRDhtDWdA8ApRYsSUCDHNt5ul13vz4w0vWCgUnnEc975arX6ORqN3VqtVZbfbTQC4uEHANM3jSqXymFI6yWazP2KxWAXAL9zCUa1Wy2tXVxheKA9YNoR8Pt+aTqe4FVVVvz05O6MBhqUIBGk8Hn8HAOVy+T+XLJfLS4ZhTiRJgqIoVBRFIoric47jPnmeB1mW/9rr9ZpSSn3Lsmir1fJZlqWlUonKsvwWwD8ymc/nXwVBeLjf7xEKhdBut9Hr9WgmkyGEkJwsy5eHG5vN5g0AKIoCAEgkEkin0wQAfN9/cXPdheu6P33fBwB4ngcAcByHJpPJl+fn54mD3Gg0NrquXxeLRQAAwzAYj8cwTZPwPH9/sVg8PXweDAauqqr2cDjEer1GJBLBZDJBs9mE4zjwfZ85lAGg2+06hmGgXq+j3+/DsixYlgVN03a9Xu8jgCNCyIegIAgx13Vfd7vdu+FweG8YRkjXdWy329+dTgeSJD3ieZ7RNO0VAXAPwDEAO5VKndi2fWrb9jWl9Esul6PZbDY9Go1OZ7PZ9z/lyuD3OozU2wAAAABJRU5ErkJggg==" alt="[LOGO]"></a>
</div></footer>
</div>
</body>
</html>
